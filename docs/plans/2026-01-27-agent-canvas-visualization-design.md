# Agent 画布可视化设计

## 项目愿景

### One Thing, Two Views

画布是人和 Agent 的**共享工作空间**。同一个画布，两种视角：

- **人的视角**：在画布上组织、排列、创作自己的内容
- **Agent 的视角**：看到画布上的内容，理解空间关系，在画布上执行操作、留下产出

两者在同一个空间里协作，而不是各自在各自的界面里。

### MVP 选择

从三种方案中选定了 **「Agent 操作画布」**：

| 方案 | 说明 | 选定？ |
|------|------|--------|
| Agent 操作画布 | Agent 能看到画布、分析内容、添加产出到画布上 | **是** |
| 画布操作 Agent | 用户在画布上拖拽组件来编排 Agent 工作流 | 否（太复杂） |
| 双向协作 | 以上两者结合 | 否（先做好一个方向） |

MVP 用 mock 数据验证交互设计，不接真实 Agent API。

---

## 核心认知

### 1. 画布 vs CLI 的本质差异

CLI 里用户「不关心过程」，不是因为过程不重要，而是 CLI 只有线性文字流，没法把过程展示好。

画布的独特价值是**空间关系**：
- Agent 分析某张图 → 画布上那张图可以被高亮
- Agent 搜索了外部资料 → 参考来源可以作为卡片出现在空间中
- Agent 的分析报告 → 和被分析的对象在同一个空间里，可以对比查看

### 2. 围绕内容互动，而不是围绕对话互动

CLI 里人和 Agent 围绕**对话**互动——你一句我一句，内容淹没在聊天流里。

画布里人和 Agent 围绕**内容本身**互动：
- 用户可以**直接指向内容**说「这里不对」，不需要用文字描述位置
- 用户可以**把材料拖上来**让 Agent 整合，不需要猜 Agent 记不记得
- 所有讨论过的东西**同时可见**，不会迷失在线性对话流里

**对话是手段，内容才是目的。画布让双方直接指向内容本身。**

### 3. 过程的价值：可感知、可追溯，但不抢戏

用户是不是只关注最终产物？不是——但过程必须以正确的方式呈现。

**过程在三个场景有明确价值：**

- **信任建立**：用户把任务交给 Agent，心里有不确定性。画布上看到 Agent 正在高亮第二张图、正在读取内容，信任感完全不同。CLI 里用户只能「信或不信」，画布里用户可以「看到」
- **纠偏时机**：Agent 搜索了错误的关键词、漏看了一张图——画布上过程可见，用户可以更早介入，而不是等结果出来才发现问题
- **外部资料的独立价值**：Agent 搜索的参考资料、引用的链接，本身就有价值。CLI 里它们埋在文字流里用完就丢，画布上可以作为独立卡片留下来

**但前提是不能喧宾夺主。** 用户注意力主要在产出物上，过程是「需要时才看」的。所有过程平铺 = 信息过载（Flowith 的教训）。

**设计原则：过程可感知、可追溯，但默认不抢注意力。产出物是主角，过程是支撑。**

### 4. 画布能释放的被 CLI 埋没的价值

核心问题：人和 Agent 协作时，有什么重要的事情，因为 CLI 的线性文字流无法承载，被用户被迫忽略了？画布能在不增加认知负担的前提下，把这些价值释放出来吗？

| CLI 里被忽略的 | 为什么被忽略 | 画布怎么做到 |
|--------------|------------|------------|
| **Agent 正在看什么** | CLI 只有一句「正在分析...」，用户不知道 Agent 在看哪张图 | 被处理的对象轻微高亮，用户余光就能感知，不需要主动关注 |
| **推理依据的可追溯性** | 结论和依据混在大段文字里，找不到 | 结论和依据在空间上靠近——报告旁边就是参考来源卡片 |
| **多个产出物之间的关系** | CLI 里产出物是一段接一段的文字，看完就忘前面 | 同时存在于空间中，可并排、交叉比较 |
| **Agent 没做什么** | CLI 里用户根本不会意识到 Agent 漏看了什么 | 画布上未被高亮的对象，本身就在告诉用户「这些 Agent 没看」 |
| **历史产出的累积** | 多轮对话后前面的产出已经滚出屏幕 | 所有东西都还在画布上，随时可回看，不需要翻聊天记录 |

这张表的关键洞察：画布不是把 CLI 里的信息「搬过来」，而是利用**空间本身**传递信息。高亮、位置关系、「不在那里」——这些都是文字流做不到的信息通道。

### 5. 用户是画布的主人

用户不是被动接收 Agent 输出的人。用户可以：
- 拖动、删除、缩放、重新排列 Agent 产出的任何东西
- 按自己的逻辑组织画布
- 保留有用的、删掉不需要的

Agent 负责「生产并放上去」，用户负责「组织和管理」。

---

## 画布 vs CLI：用户行为的变化

同样的任务，用户在画布和 CLI 里的行为完全不同。

### 场景一：「帮我分析这三张设计稿」

| | CLI | 画布 |
|--|-----|------|
| 输入 | 用户打字描述「我有三张设计稿，分别是...」 | 三张图就在画布上，Agent 自己看，用户不用描述 |
| 等待 | 一句「分析中...」，不知道在看哪张 | 正在被处理的图微微高亮，用户余光感知进度 |
| 产出 | 一大段文字，从上往下读 | 分析出现在图旁边，结论和对象空间上靠近 |
| 对比 | 读到第三张时忘了第一张说什么，需要翻回去 | 三份分析同时可见，拖到一起就是并排对比 |

### 场景二：「这个结论不对，你重新看看」

| | CLI | 画布 |
|--|-----|------|
| 指向 | 「你第二张的分析有问题，那个页面主色调不是蓝色是紫色」——用文字描述位置和内容 | 直接点第二张图或其分析卡片，说「这里不对」 |
| Agent 理解 | Agent 要从文字重新定位用户说的是哪个 | Agent 直接知道用户指的是什么（空间上下文） |

### 场景三：多轮迭代

| | CLI | 画布 |
|--|-----|------|
| 第一轮 | 分析结果在聊天流里 | 分析结果在画布上 |
| 第二轮 | 第一轮已经滚上去了 | 第一轮还在，第二轮出现在旁边 |
| 第三轮要参考第一轮 | 用户翻聊天记录找 | 都在画布上，拖到一起对比 |
| 清理 | 没有这个操作，所有历史永远在那里 | 删掉不要的，拖走有用的，画布是活的工作台 |

### 场景四：Agent 搜了外部资料

| | CLI | 画布 |
|--|-----|------|
| 呈现 | 一句话「参考了 XX 报告」+ 一个链接 | 参考资料作为卡片出现在画布上 |
| 关联 | 链接和结论之间没有空间关系 | 资料卡片和分析报告空间上靠近，依据关系可见 |
| 后续使用 | 链接埋在聊天记录里，以后找不到 | 卡片一直在画布上，用户以后还能用 |

### 场景五：用户主动组织

CLI 里**不存在这个场景**。用户是被动的接收者。

画布里：
- 用户把三份分析拖到左边，自己的笔记放右边
- 删掉过程卡片，只保留有用的产出
- 按自己的逻辑建立空间结构

**这个空间结构本身就是用户思考的外化。** CLI 里用户的思考只存在于脑子里，画布上它变成了可见的布局。

### 小结

画布改变的不是 Agent 的能力，而是人与 Agent 之间的**协作界面**：
- **从描述 → 指向**：不用说「第二张图」，直接点
- **从线性 → 空间**：不用翻记录，都在那里
- **从被动 → 主动**：不是接收输出，而是组织、管理、指挥
- **从消失 → 持久**：不是用完就滚走，而是留在工作台上

---

## Agent 行为分析

### 示例场景

画布上有 3 张设计稿，用户说：「帮我分析这些设计稿，写一份报告」

**完整流程：**

| 序号 | 类型 | 内容 |
|------|------|------|
| 1 | 用户消息 | 「帮我分析这些设计稿，写一份报告」 |
| 2 | 思考 | 理解用户意图 |
| 3 | 工具调用（内部） | `get_canvas_tree()` → 获取画布结构 |
| 4 | 思考 | 有 3 张图，逐个分析 |
| 5 | 工具调用（内部） | `get_node_detail(id1)` → 读取第一张图 |
| 6 | 工具调用（内部） | `get_node_detail(id2)` → 读取第二张图 |
| 7 | 工具调用（内部） | `get_node_detail(id3)` → 读取第三张图 |
| 8 | 工具调用（外部） | `web_search("2026 UI design trends")` → 搜索设计趋势 |
| 9 | 思考 | 综合分析，组织报告结构 |
| 10 | **产出物** | 一份完整的分析报告（Markdown） |
| 11 | 总结评论 | 「报告已生成，建议重点关注间距统一」 |

### 行为类型归纳

| 类型 | 谁产生 | 内容长度 | 用户关注度 |
|------|--------|---------|-----------|
| 用户消息 | 用户 | 短 | — |
| 思考 | Agent | 短~长 | 低（过程） |
| 工具调用 | Agent | 短（摘要） | 低~中（过程，但外部获取有参考价值） |
| **产出物** | Agent | **长** | **高（这是用户要的）** |
| **提问/请求决策** | Agent | **短** | **高（需要用户行动）** |
| 总结/评论 | Agent | 短 | 中（收尾） |

### 用户什么时候关注什么

| 阶段 | 用户在想什么 | 需要看到什么 |
|------|------------|------------|
| 等待中 | 「卡住了没？在干嘛？」 | 进度感——Agent 在动、在做什么的一句话 |
| 拿到结果 | 「报告写得怎么样？」 | 产出物本身 |
| 追溯（偶尔） | 「这结论怎么来的？参考了什么？」 | 展开过程，查看思考链、工具调用、引用来源 |

---

## 画布上的展示设计

### 三类东西，三种处理

**过程（思考 + 工具调用 + 总结）**
- 不是用户要操作的对象
- 放在一张「过程卡片」里，折叠展示
- 等待时提供进度感，完成后可追溯

**产出物（报告、分析、建议等）**
- 用户真正要的东西
- 必须是**独立的画布对象**，用户可拖动、删除、缩放
- Agent 放到合理位置，用户自己决定最终布局

**提问/请求决策（Agent 需要用户回应的内容）**

不是独立卡片，而是**附着在已有内容上的评论气泡**（参考 Figma 评论模式）：
- 钉在相关内容的具体位置——关于产出物的问题就钉在产出物上
- 有未读标记，用户扫一眼就知道哪里需要关注
- **不打断工作流**——用户可以现在看，也可以稍后看
- 有状态流转：未解决 → 已解决（resolve 后视觉收敛）

为什么用评论而不是独立卡片？
- 独立卡片会占空间、会堆积，变成另一种信息过载
- 评论是**轻量标记**，附着在已有对象上，不是新对象
- 核心原则：**标记位置 + 不打断工作流**

应用场景：
- Agent 需要用户做决定 → 在相关内容上留评论
- Agent 不确定分析方向 → 在过程卡片上留评论
- Agent 发现画布上有矛盾 → 在相关对象上标注

**实际发现：** 当 Agent 产出变多后，用户找不到「哪里需要我行动」。CLI 里最新消息永远在底部，这个问题不存在。画布上内容散布在空间中，需要用 Figma 式的评论气泡来解决「哪里需要关注」的问题。

### Agent 修改画布时，用户如何感知

当 Agent 对画布做了改动，用户需要知道：
- **改了什么** — 哪些内容是新增的、修改的、删除的
- **为什么改** — Agent 改动的理由
- **改动范围** — 改了一点还是大幅变动

可能的方向：
- 改动部分高亮标记（类似修订模式）
- Agent 改动后附简短说明
- 改动历史可追溯

---

## 三个关键约束

### 1. 单一任务的完整性

一个任务产出：1 张过程卡片 + N 个产出物卡片。

**问题**：产出物独立后，用户怎么知道它们属于同一个任务？

可能的方案：
- 视觉标记（相同颜色/编号）
- 连线关系
- 产出物上标注来源任务
- 过程卡片里有产出物的索引

### 2. 单一对话的交互性

用户不会只说一句话。多轮对话下来，每轮可能产出新东西。

**问题**：多轮产出累积，画布怎么不乱？

可能的方案：
- 用户自己整理（删掉不要的，拖走有用的）
- 过程卡片可删除，不影响产出物
- 新一轮过程卡片替换上一轮？还是并列？

### 3. 单一画布的复杂度

画布上本来就有用户自己的内容。Agent 的东西是附加的。

**问题**：Agent 内容怎么不喧宾夺主？

可能的方案：
- Agent 内容有明确的视觉区分
- 默认放置位置在空白区域
- 用户可以一键清理 Agent 内容

---

## 待讨论

1. 过程卡片和产出物之间的**视觉归属关系**怎么表达？
    1. 考虑用空间或连线，作两个版本
    2. 考虑一下哪些是最终产物，哪些是过程产物，哪些需要被保留在画板，如果不需要的话只考虑最终产物的关系就好
2. 产出物的**默认放置位置**——过程卡片旁边？相关对象旁边？
    1. 同上，其实我们要先了解，哪些是用户关注的，在去思考这些东西是否有关系
3. 外部资料获取（搜网页、看链接）算「过程」还是「产出物」？
    1. 需要被教验的过程产物，就像写论文，会引用很多资料，但是最终结果还是论文本体
4. 过程卡片的**生命周期**——永久保留？自动折叠？可删除？
    1. 自动摺叠，我们要做到可追朔
5. 多轮对话——每轮一张新过程卡片？还是同一张追加？
    1. 同之前的问题，哪些是要保留的
6. Agent 修改画布内容时，用户如何感知变更？
    1. Agent的行为可视化，包含几个部分
        1. 参考和引用画布上的内容
        2. 本身行为（使用工具和思考）
        3. 反馈->comment
7. 用户如何确认 Agent 是否遗漏了上下文？
    1.可追朔的过程
    2. Agent行为的可视化

---

## 本文档的 meta 意义

这份文档本身就是我们在探索的案例。

在写作过程中，我（Agent）和你（用户）的协作模式恰好复现了画布上会遇到的问题：
- Agent 整理内容、产出文档 → 画布上的「产出物」
- 用户审阅、指正方向 → 画布上的「用户操作」
- 用户问「之前的文档整进来了吗」→ 画布上的「Agent 是否遗漏上下文」
- 用户无法感知 Agent 改了什么 → 画布上的「变更感知」问题

我们在 CLI 里碰到的每一个协作摩擦，都是画布产品要解决的问题。

---

## 类似产品分析

市面上已有多个将 AI/Agent 与画布结合的产品，但切入角度各不相同。

### 深度调研产品列表

| 产品 | 核心模式 | 交互范式 | 与我们的关系 |
|------|----------|---------|------------|
| **Lovart** | AI 设计 Agent + ChatCanvas，Talk.Tab.Tune 三层交互 | 对话式标注 | **最值得参考的交互模型**——在画布上直接标注 + 对话，输入输出在同一表面 |
| **Flowith** | 每次对话 = 画布上一个节点，节点可分支、连接、并排比较 | 分支树 | 「对话节点化」，核心仍是聊天。信息过载是核心反面教材 |
| **Flora** | 节点式无限画布，每个节点 = 一个 AI 模型，连线构成管线 | 节点流水线 | 偏向多模型编排，交互重在搭建管线而非与 Agent 对话 |
| **Krea** | 实时画布：画一笔 AI 就渲染，<50ms 延迟；另有 Nodes 高级模式 | 实时镜像 | 最极端的「画布原生交互」——没有生成按钮，操作即输入 |
| **TapNow** | AI 视觉创作引擎，支持文字/草图/上传多种输入 | 混合触发 | Draw-to-Video 有趣，但偏电商/影视，参考价值有限 |
| **Jeda.ai** | AI 白板，/ 命令触发，300+ AI Recipe | 命令触发 | 「上下文跟着对象走」+ ai+ 按钮在任意节点扩展，值得参考 |
| **Heuristica** | AI 知识画布，按钮式提问（What/Who/Why）生成概念树 | 按钮触发 | 无需写 prompt 的交互模式有启发 |
| **Napkin** | 文字优先，AI 在旁边提供可视化选项（spark 图标） | 内容火花 | 「内容先行，AI 辅助」的模式——不是 AI 先行 |
| **tldraw computer** | 画布编排 AI 工作流 | 节点流水线 | 「画布操作 Agent」方向，我们选的是反方向 |
| **tldraw Agent Starter Kit** | 聊天面板 + 画布，Agent 读写画布 | 聊天驱动 | 架构最接近，但交互仍是传统聊天 |
| **Pencil.dev** | IDE 内嵌画布，AI 生成代码，只展示最终产物 | 生成型 | 选择隐藏过程，在生成型任务中是对的 |

### 六种交互范式

从调研中归纳出 AI 画布产品的六种交互范式：

| 范式 | 代表 | 用户怎么触发 AI | 输出怎么出现 | 过程可见性 |
|------|------|---------------|------------|-----------|
| **对话式标注** | Lovart | 在画布上标注 + 自然语言 | 直接在同一表面更新 | 对话流实时可见 |
| **节点流水线** | Flora, Krea Nodes | 拖拽节点 + 连线 + 运行 | 节点内预览 | 每个节点独立状态 |
| **分支树** | Flowith, Heuristica | 输入框打字 / 按钮点击 | 新节点分支出现 | 节点树即过程 |
| **实时镜像** | Krea 实时画布 | 画笔、形状、任何画布操作 | <50ms 实时渲染到镜像面 | 无需过程——即时反馈 |
| **命令触发** | Jeda | / 命令、ai+ 按钮 | 结构化图表出现在画布上 | 即时生成 |
| **内容火花** | Napkin | 写文字后点 spark 图标 | 旁边出现多种可视化选项 | 无需过程——按需触发 |

### 白板 + AI 方向

| 产品 | 模式 | 启发 |
|------|------|------|
| **Miro AI** | 传统白板 + AI 辅助（生成便利贴、聚类、摘要） | AI 是附加功能，不是核心交互。但「AI agent 作为数字队友」的概念值得参考 |
| **FigJam AI** | 白板 + AI 生成模板、时间线 | AI 产出直接成为画布对象，这和我们「产出物 = 独立画布对象」的思路一致 |

### 关键观察

**1. 没有产品在做我们要做的事**

现有产品可以归为四类，我们是第五类：
- **对话节点化**（Flowith）：把聊天变成节点放在画布上，本质还是围绕对话
- **画布编排 AI**（tldraw computer, Flora）：用画布组件来编排 AI 工作流
- **生成型画布**（Pencil.dev）：用户画设计 → AI 生成代码，只展示最终产物
- **对话式标注**（Lovart）：在画布上直接标注 + 对话，AI 在同一表面响应

我们要做的第五件事：**让用户看到 Agent 在画布上做了什么、正在做什么**——Agent 的行为本身成为画布上的可视化内容。这个方向目前没有产品在做。

**2. 任务类型决定了过程是否有价值**

Pencil.dev 选择只给最终结果，这在它的场景里是对的。关键差异在于**任务类型**：

| | 生成型任务（Pencil） | 分析/判断型任务（我们） |
|--|---------------------|---------------------|
| 产出物 | 代码——有明确对错 | 报告、分析——没有标准答案 |
| 验证方式 | 跑一下就知道对不对 | 需要理解推理过程才能判断 |
| 过程价值 | 低——用户不关心 AI 怎么写代码 | 高——依据、来源、覆盖范围都影响信任 |
| 出错成本 | 低——重新生成一次 | 高——用户可能基于错误分析做决策 |

**这解释了为什么 Pencil 可以只给结果，而我们不能。** 当用户无法通过「看一眼」验证产出物的对错时，过程就变成了判断质量的唯一依据。

**3. 值得参考什么、参考哪个部分**

最有价值的参考反而不全是 AI 画布产品：

| 参考对象 | 参考什么 | 对应我们的什么问题 |
|---------|---------|-----------------|
| **Figma 多人协作** | 多角色在同一画布上协作：光标可见、谁在看哪里、修改实时同步 | Agent 就是画布上的另一个「人」，协作模式直接适用 |
| **GitHub PR diff** | 让人感知他人的改动：增删改的视觉化、变更范围、review 流程 | Agent 修改画布时，用户需要类似的变更感知 |
| **tldraw Agent Starter Kit** | Agent 读写画布的 API 设计、聊天面板 + 画布的双面板架构 | 技术架构直接借鉴 |
| **Flowith** | 空间化展示 AI 过程有需求（正面）；信息过载是核心风险（反面） | 过程展示的度——可感知但不过载 |
| **Jeda.ai** | 上下文跟着画布对象走——分析结果附着在被分析对象旁边 | 产出物的默认放置位置策略 |
| **Spotlight / Raycast** | 召唤式输入，轻量、不打断当前操作 | Agent 输入栏的交互模式 |

**4. Flowith 的经验教训**

Flowith 是最接近的参考。它的问题恰好印证了我们文档里提到的三个约束：
- **画布复杂度**：多轮对话后节点堆积，用户反馈「信息过载」
- **任务完整性**：节点分散后难以追溯一个完整任务的全貌
- **学习曲线**：新用户需要 15-20 分钟适应非线性界面

**5. tldraw 生态的价值**

tldraw 官方已经在 AI + 画布方向投入很多（computer、Agent Starter Kit、Make Real）。我们用 tldraw 作为底层，可以直接复用其画布交互能力，专注在 Agent 行为可视化这一层。

---

## 交互模型重新思考

### 核心问题：AI 输出量 >> 人类注意力

Flowith 为什么让人觉得「不行」？不是技术不好，是它把 Agent 每一步都当成值得占画布空间的东西。结果画布上堆满节点，用户反而迷失。

**所有 AI 画布产品共同的未解问题**：画布组织最终变成用户的负担。没有一个产品真正解决了这件事。

这意味着我们的核心设计挑战不是「怎么展示 Agent 行为」，而是**如何正确安排用户的注意力——在不同阶段，什么需要被关注**。

### 注意力是分阶段的

一次 Agent 任务不是瞬间完成的。用户的注意力需求随阶段变化：

| 阶段 | 用户状态 | 需要关注什么 | 不需要关注什么 |
|------|---------|------------|-------------|
| **发出指令** | 「收到了没？」 | 确认感——Agent 开始了 | 任何细节 |
| **执行中** | 「方向对不对？卡住了没？」 | 进度感 + 方向感——Agent 在看什么、做什么 | 具体思考内容 |
| **产出中** | 「结果怎么样？」 | 产出物本身 | 过程细节 |
| **完成后** | 判断质量、决定下一步 | 产出物 + 按需追溯过程 | 过程（除非主动查看） |
| **之后回来** | 回顾、复用 | 产出物 + 上下文关系 | 过程（除非需要理解「为什么」） |

### 用户可以随时介入

过程不是单向的。现在 Agent 的能力已经支持用户在中途插入新消息、修正方向、补充信息。

介入场景：
- 执行中，用户看到 Agent 在分析错误的图 →「不是那张，是右边那张」
- 产出中，用户看到方向不对 →「不要比较颜色，我要比较布局」
- Agent 还在做任务 A，用户又丢了任务 B
- 用户把新素材拖上画布 → 等于在说「也看看这个」

画布上要解决：用户怎么介入？介入后 Agent 和画布怎么响应？

### 画布上不应该长一个 CLI

如果还是底部一个输入框打字，那画布只是 CLI 的背景板。

从调研中看到的画布原生交互方式：

| 交互方式 | 参考产品 | 等于在说什么 |
|---------|---------|------------|
| **选中对象 + 上下文菜单** | Lovart Talk.Tab.Tune | 「分析这个」「解释这个」 |
| **框选多个对象 + 一句话** | Lovart 区域标注 | 「比较这三个」 |
| **在产出物上留标记/评论** | Lovart + Figma | 「这里不对」「展开说说」 |
| **拖拽新内容到画布** | Lovart canvas-as-context | 「也考虑这个」 |
| **删掉 Agent 产出** | 所有画布工具 | 「这个不要」 |
| **在任意节点点 ai+** | Jeda | 「从这里继续」 |

**文本输入栏保留但降级为辅助**——只有表达复杂意图时才需要打字。大部分交互应该通过画布操作完成。

### 最值得参考的三个交互模式

**1. Lovart「Talk.Tab.Tune」—— 三层递进**

自然语言（粗略意图）→ 空间标注（精确指向）→ 参数调整（细节控制）。用户不需要一开始就精确描述，可以逐步细化。这和我们的场景高度契合：用户先说「分析这些」，然后指着具体位置说「这里不对」。

**2. Krea 实时镜像 —— 操作即输入**

没有「生成」按钮，用户的每个画布操作都立即反映在 AI 输出上。虽然我们的场景不是图像生成，但核心思路可借鉴：**用户在画布上的操作（选中、拖拽、删除、标注）本身就是和 Agent 沟通**，不需要额外的「发送」步骤。

**3. Lovart「Canvas as Context」—— 画布即上下文**

AI 自动读取画布上的所有内容作为上下文。用户把品牌素材放在旁边，AI 自动用上。这意味着用户组织画布的行为，同时也在组织给 Agent 的上下文。

### 所有产品共同的失败点

1. **画布越来越乱** —— 没有产品真正解决自动组织
2. **学习曲线** —— 从线性聊天到空间思维的心智模型转变是最大的采用障碍
3. **简单任务杀鸡用牛刀** —— Flowith 用户反馈「简单问题不需要画布」
4. **性能随规模下降** —— 画布内容多了之后都卡

---

## 验证场景：用 AI 做 PPT

### 为什么选 PPT

画布是自由的，可以做任何事——但「什么都能做」等于用户不知道该拿它做什么。我们需要找到**画布比对话更擅长的场景**来验证方向。

PPT 命中了画布优于对话的三个特征：

| 特征 | 为什么对话做不好 | 画布怎么解决 |
|------|---------------|------------|
| **多内容**（多张幻灯片，多阶段产物） | 讨论第 15 页时忘了第 3 页说什么 | 全部摊开，同时可见 |
| **多模态**（视频/图片/文字） | 只能贴链接或用文字描述「那张图」 | 直接看到 |
| **多修改**（不可能一次搞定） | 改第三版要翻回去找第一版 | 版本并排比较 |

而且 PPT 天然是空间化的——每张幻灯片就是一个画布对象，用户对「空间中排列卡片」的心智模型已经存在。

**重要**：PPT 是验证场景，不是产品方向。画布 + Agent 的核心能力如果成立，PPT 只是其中一种用法。

### 场景走查：「做一个画布产品的市场汇报」

#### 第一步：用户发出指令

用户说：「帮我收集一下好的画布产品」

#### 第二步：Agent 搜索并产出

Agent 搜索后，把每个产品作为**独立卡片**放到画布上（而不是一张汇总列表）。

为什么是独立卡片：
- 用户可以删掉不关心的
- 可以拖拽重新排序
- 可以单独对某张说「深入研究」
- 汇总列表的自由度太低，回到了对话/文字的交互模式

**卡片的信息层级设计**：
- **表面层**：产品名 + 一句话描述 + 关键标签 → 扫一眼就知道值不值得看
- **暗示层**：视觉上暗示「里面还有更多」→ 展开箭头、内容截断
- **深层**：完整调研内容 → 用户主动展开才看到

核心原则：**适当的信息量 + 告诉用户还有更多 + 提供快速校验和深入研究的空间**。默认只占最少注意力，随时可深入。

#### 第三步：用户操作画布

用户扫一遍卡片，删掉不相关的，框选感兴趣的几个，说「帮我提炼一下这些的共性」。

这里体现了画布原生交互：
- **删除** = 「这个不要」
- **框选 + 一句话** = 「基于这些做什么」
- 不需要打字描述「请基于 Lovart、Krea、Flowith 这三个产品...」

#### 第四步：深入研究

用户指着 Lovart 卡片说「这个的交互模式再深入研究一下」。

Agent 产出的深入内容出现在 **Lovart 卡片附近**——空间位置表达从属关系。不是出现在画布另一个角落让用户找不到关联。

### 三个待解决的交互问题

#### 1. Agent 的主动性

Agent 完成搜索后，是否应该主动提建议？比如「这些产品可以按交互模式分成三类，要我帮你归类吗？」

判断：**应该主动，但用轻量方式（comment），不直接行动。** 标记出来，不打断。用户可以理、可以不理。如果 Agent 直接帮你归了类，用户可能觉得「我还没看完你就动了」。

#### 2. 对话的空间组织

用户对 Lovart 深入研究的产出，和原来的 8 张卡片，在画布上怎么组织？

判断：**空间位置表达从属关系。** 深入研究的内容出现在相关卡片附近，自然成组。这是画布比对话强的地方——对话里「深入研究 Lovart」的结果和其他讨论混在一起，画布上 Lovart 相关内容就在 Lovart 旁边。

#### 3. 目标可以变，上下文不丢

用户做着 PPT，突然说「算了做成视频」。Agent 怎么处理？

判断：
- **不强制用户围绕目标**——画布是自由的，目标转换是正常的创作过程
- **之前的产出都还在画布上**，做视频时可以复用
- **Agent 感知变化但不阻拦**——可以问「之前的调研内容要保留还是重新来？」但不应该说「你不是要做 PPT 吗」

### Agent 的角色定位

Agent 应该是助手还是协作者？

- **助手**：用户说什么做什么，不质疑
- **协作者**：有自己的判断，会提出不同意见

判断：**Agent 提出建议或挑战的前提是，它能给出用户自己没想到的依据。** 不是为了挑战而挑战，也不是为了顺从而顺从。

画布上比对话更容易做到这件事——因为 Agent 能「看到」画布上所有素材的状态，它的判断基于可见的事实，而不是空泛的意见。

角色定位影响的是内容策略（说话语气、主动性程度、挑战尺度），不影响交互结构。可以后续调整。

---

## 结论与下一步

### 我们到目前为止确认了什么

**方向判断：**

1. **画布的核心价值不是「更好看的聊天界面」，而是空间本身作为信息通道。** 高亮、位置关系、缺席——这些是文字流做不到的。
2. **过程不是没价值，是 CLI 没能力展示。** 画布能在不增加认知负担的前提下，让过程可感知、可追溯。
3. **任务类型决定了我们必须展示过程。** 分析/判断型任务没有「跑一下就知道对不对」的验证方式，过程是用户判断质量的唯一依据。
4. **没有产品在做我们要做的事。** 现有产品是对话节点化、画布编排 AI、对话式标注、或生成型画布。Agent 行为可视化是空白。
5. **用户不是被动接收者，是画布的主人。** 从描述→指向，从线性→空间，从被动→主动，从消失→持久。
6. **画布比对话擅长的场景有明确特征。** 多内容、多模态、多修改的任务，画布提供对话做不到的价值。PPT 制作是第一个验证场景。

**设计原则：**

- 过程可感知、可追溯，但默认不抢注意力
- 产出物是独立画布对象（每个一张卡片），用户可删、可拖、可展开
- 卡片有信息层级：表面快速校验、深层按需展开
- Agent 是画布上的协作者，不是对话框里的回答者
- **注意力管理是核心设计挑战**——不同阶段展示不同信息，AI 输出量 >> 人类注意力
- **画布操作即交互**——文本输入是辅助手段，选中/框选/标注/拖拽/删除才是主要沟通方式
- **用户可随时介入**——过程不是单向的，画布要支持中途修正和补充
- **深入研究的内容出现在相关卡片附近**——空间位置表达从属关系
- **Agent 主动建议用轻量方式**——comment，不直接行动，用户可以理也可以不理
- **目标可以变，上下文不丢**——不强制围绕目标，之前产出留在画布上可复用

### 下一步：用 PPT 场景做第一个可用原型

用「做一个画布产品的市场汇报 PPT」作为验证场景，实现最小可用的交互流程：

**要做的：**
1. 用户发出指令 → Agent 搜索并产出多张独立卡片到画布上
2. 卡片有信息层级（表面/暗示/深层）
3. 用户可以通过画布操作（删除、框选）和 Agent 沟通
4. 深入研究的产出出现在相关卡片附近

**验证的问题：**
- 独立卡片 + 画布操作，是否比对话里的文字列表提供了明确的新价值？
- 信息层级设计是否让用户能快速校验 + 按需深入？
- 空间组织是否自然？

### 每一步之后都要回答的问题

- 这个交互是否比 CLI 提供了**明确的新价值**？
- 如果去掉这个功能，用户会**失去什么**？
- 这个信息是否**喧宾夺主**了？

---

## 当前实现状态

### 已完成
- `AgentCardShape.tsx`：自定义 tldraw ShapeUtil，一轮对话 = 一张卡片
- `AgentInputBar.tsx`：底部浮动输入框
- `agentMockData.ts`：mock 数据生成（AgentStep[] 格式）
- `handleAgentMessage`：创建一张卡片并逐步更新 steps

### 需要重构（对应下一步第一步）
- 当前所有内容塞在一张卡片里 → 拆分为「过程卡片 + 独立产出物」
- 产出物需要成为独立画布对象
- 默认布局策略待设计
