# CLI → 画布翻译：核心问题

## 背景

我们已经把 Claude Code CLI 接入了画布——用户在画布输入框打字 → 本地中继服务 → spawn claude -p → SSE 流式返回 → 渲染到画布上。技术链路跑通了。

但跑通之后暴露了一个本质问题：**现在只是把 CLI 输出搬到了画布上，没有真正做"翻译"。**

用户的原话：「实际上会吐出一个很长的文本，这样的话跟用cli就没差别了」

## 已有的成功翻译

Mock 流程其实已经做了很好的翻译：

| 用户说的 | CLI 等价 | 画布上的翻译 |
|---------|---------|------------|
| 「收集画布产品」 | Claude 搜索并写一段文字 | **8 张独立产品卡片**，每张可展开/删除/深入研究 |
| 「组织成大纲」 | Claude 输出大纲文字 | **大纲卡片**，可拖拽调整顺序，一键生成页面 |
| 「生成页面」 | Claude 写出幻灯片文字 | **N 张页面卡片**，网格排列，可编辑内容 |
| 「导出 PPT」 | 下载 .pptx 文件 | **文件卡片**，显示文件名和大小，可下载 |

这些之所以有效，是因为**我们知道产出是什么类型**，所以能把文字翻译成对应的画布对象。

## 真实 CLI 的问题

Claude CLI 返回的是自由格式文本。它可能是：
- 一段分析
- 一段代码
- 一个方案比较
- 一个简单回答
- 上面的任意组合

我们不知道它是什么类型，所以只能塞进一个通用的 `agent-card` 里。结果就是：画布上出现了一个文字墙，跟终端没差别。

## 核心问题

### 什么东西值得出现在画布上？

回到设计文档的原点：

> 画布不是把 CLI 里的信息「搬过来」，而是利用空间本身传递信息。

判断标准不是"内容好不好"，而是：**这个东西放在画布上之后，用户能拿它做什么？**

画布上的对象有价值，当且仅当用户之后会：
- **再看它**——回来参考
- **操作它**——拖走、删除、跟别的东西放一起比较
- **基于它继续**——选中它说「这个再深入」

如果用户只是看一眼就完了，那它不该占画布空间。

### 几个可能的方向

**方向 A：只留信物**

真实 CLI 调用完成后，画布上只留一个小标记（类似 git commit），记录"做了什么"。不强行把文字塞到画布上。

- 优点：画布保持干净
- 问题：那为什么要在画布上触发 CLI？在终端里做不就好了？

**方向 B：让 Claude 自己决定产出什么**

在 prompt 里告诉 Claude 画布上有哪些形状可用（产品卡片、分析卡片、文件卡片...），让它自己决定产出什么类型的画布对象。

- 优点：自动匹配最合适的呈现方式
- 问题：需要定义"画布 API"——Claude 要知道可以创建什么、怎么创建。这实际上是 tool_use 的思路。

**方向 C：先不翻译**

现阶段真实 CLI 只用来做"背后的工作"（改代码、跑命令、查文件），画布上的产出物继续用专门设计的流程（mock 或结构化调用）。

- 优点：不用解决翻译问题
- 问题：CLI 和画布变成两个独立的东西，没有真正整合

**方向 D：两层分离**

- **过程层**：CLI 的执行过程只在状态栏显示（已实现）
- **产出层**：完成后，不自动放东西到画布上。而是弹出一个"结果预览"，用户决定要不要放到画布上、放成什么形状

- 优点：用户有控制权
- 问题：增加了一步操作

## 更深层的问题

也许问题不是"怎么翻译 CLI 输出"，而是：

**用户在画布上使用 CLI 的场景到底是什么？**

如果用户只是想问 Claude 一个问题（"React 和 Vue 哪个好？"），把答案放在画布上确实没有意义。

但如果用户的意图是**往画布上添加一个有用的对象**（"帮我分析这个代码库的架构"→ 产出一张架构图卡片），那翻译就有明确方向了。

**也许答案是：不是所有 CLI 任务都适合在画布上做。画布上的 Agent 应该只做那些产出物是画布对象的任务。**

## 进一步讨论（2026-01-29 晚）

### 拆成多张卡片？→ 不对

如果把一份文档的每个章节都拆成独立卡片放在画布上，就变成了 Flowith——铺满节点，认知超载。画布的对象数量应该由用户决定（发了几个任务），而不是由内容长度决定。

### 有些任务本来就不适合画布

"写一份设计文档"这个任务：产出物是线性长文，用户操作是从头读到尾，不需要空间操作。它在 CLI / 对话里做更合适。

画布真正有优势的任务特征：**多内容、可操作、空间有意义。** PPT 流程之所以成立：8 张产品卡片同时在画布上，删不要的，选几张深入——这些是 CLI 做不到的。

### Claude 的两类产出

1. **文本/文档**——Claude 最自然的输出格式。分析报告、方案对比、代码解释...
2. **操作/动作**——创建卡片、生成图片、修改画布对象... 需要工具支持

关键认知：**如果给 Claude 足够多的工具，翻译问题就消失了。**

- 没有工具：Claude → 文本 → **需要翻译** → 画布对象
- 有工具：Claude → **直接调用工具创建画布对象** → 画布对象

工具本身就是翻译层。Claude 不再是"写字然后让前端转换"，而是直接在画布上"做事"。

### 核心转变

从"翻译 CLI 输出"转向"给 Claude 提供画布工具"。问题从"怎么把文章变成卡片"变成"画布应该暴露哪些工具给 Claude"。

可能的工具方向：
- `create_card(name, tagline, tags, detail)` — 创建产品/概念卡片
- `create_outline(title, items)` — 创建大纲
- `create_image(prompt)` — 生成图片放到画布上
- `read_canvas()` — 读取画布上的内容作为上下文
- `highlight(shapeId)` — 高亮某个画布对象
- ...

技术路径：CLI 支持 MCP tools，画布可以把自己暴露为 MCP server。

## 待思考

1. 画布应该暴露哪些工具给 Claude？最小可用集是什么？
2. 用 MCP 还是用 prompt 包装的 JSON 方案？
3. 哪些任务适合画布（多内容、可操作、空间有意义），哪些应该留给 CLI？入口如何引导？
4. 工具调用的实时可视化——Claude 调用 `create_card` 时，画布上怎么表现这个过程？
